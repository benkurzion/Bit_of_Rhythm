import numpy as np
import cv2
import tkinter as tk
from tkinter import filedialog
import os

'''
General Skeleton
1) Perform canny edge detection. Use paper's strategy to find the ellipse (head of the drum stick)
2) Identify surface on which the stick are producing rhythm
3) Follow papers algorithm to produce probability that there is a strike at every frame n.
4) Run Kuhn-Munkres algorithm to transcribe time series

'''



def select_video_file():
    file_path = filedialog.askopenfilename(
        title="Select a Video File",
        filetypes=(
            ("Video files", "*.mp4 *.avi *.mov *.mkv"),
            ("All files", "*.*")
        )
    )
    
    return file_path


def process_video_frame_by_frame():
    video_path = select_video_file()
    cap = cv2.VideoCapture(video_path)
    
    # Loop through video frames
    while True:
        ret, frame = cap.read()

        # If ret is False -> video has ended
        if not ret:
            print("Finished processing all frames.")
            break

        # PROCESS THE FRAME: frame = NumPy array in BGR format
        
    cap.release()
    cv2.destroyAllWindows()


def compute_luv_gradient_magnitude_fast(img):
    """
    Faster vectorized version using convolution-like operations.
    Computes edge magnitude from L*u*v color differences.
    
    Args:
        img: Input BGR image
    
    Returns:
        Edge magnitude map
    """
    # Convert to L*u*v
    luv_img = cv2.cvtColor(img, cv2.COLOR_BGR2Luv).astype(np.float32)
    
    # Separate channels
    L, u, v = cv2.split(luv_img)
    
    # Compute gradients for each channel using Sobel
    L_grad_x = cv2.Sobel(L, cv2.CV_64F, 1, 0, ksize=3)
    L_grad_y = cv2.Sobel(L, cv2.CV_64F, 0, 1, ksize=3)
    
    u_grad_x = cv2.Sobel(u, cv2.CV_64F, 1, 0, ksize=3)
    u_grad_y = cv2.Sobel(u, cv2.CV_64F, 0, 1, ksize=3)
    
    v_grad_x = cv2.Sobel(v, cv2.CV_64F, 1, 0, ksize=3)
    v_grad_y = cv2.Sobel(v, cv2.CV_64F, 0, 1, ksize=3)
    
    # Compute magnitude for each channel
    L_mag = np.sqrt(L_grad_x**2 + L_grad_y**2)
    u_mag = np.sqrt(u_grad_x**2 + u_grad_y**2)
    v_mag = np.sqrt(v_grad_x**2 + v_grad_y**2)
    
    # Combined magnitude (Euclidean norm across channels)
    edge_magnitude = np.sqrt(L_mag**2 + u_mag**2 + v_mag**2)
    
    return edge_magnitude


def modified_edge_detection(img, d=9, sigma_color=75, sigma_space=75, 
                        low_thresh=20, high_thresh=50, use_fast=True):
    """
    Complete edge detection pipeline as specified in the paper:
    1. Bilateral filtering instead of Gaussian smoothing
    2. L*u*v color-based gradient magnitude
    3. Hysteresis thresholding
    
    Args:
        img: Input BGR image
        d: Bilateral filter diameter
        sigma_color: Bilateral filter sigma in color space
        sigma_space: Bilateral filter sigma in coordinate space
        low_thresh: Low threshold for hysteresis
        high_thresh: High threshold for hysteresis
        use_fast: Use fast vectorized version (recommended)
    
    Returns:
        Ec: Coarse edge map
        Ef: Fine edge map
        edge_magnitude: Raw edge magnitude values
    """
    # Step 1: Apply bilateral filtering
    filtered = cv2.bilateralFilter(img, d, sigma_color, sigma_space)
    
    # Step 2: Compute edge magnitude using L*u*v color differences
    luv_img = cv2.cvtColor(filtered, cv2.COLOR_BGR2Luv).astype(np.float32)
    L, u, v = cv2.split(luv_img)
    
    # Compute gradients for each channel using Sobel
    L_grad_x = cv2.Sobel(L, cv2.CV_64F, 1, 0, ksize=3)
    L_grad_y = cv2.Sobel(L, cv2.CV_64F, 0, 1, ksize=3)
    
    u_grad_x = cv2.Sobel(u, cv2.CV_64F, 1, 0, ksize=3)
    u_grad_y = cv2.Sobel(u, cv2.CV_64F, 0, 1, ksize=3)
    
    v_grad_x = cv2.Sobel(v, cv2.CV_64F, 1, 0, ksize=3)
    v_grad_y = cv2.Sobel(v, cv2.CV_64F, 0, 1, ksize=3)
    
    # Compute magnitude for each channel
    L_mag = np.sqrt(L_grad_x**2 + L_grad_y**2)
    u_mag = np.sqrt(u_grad_x**2 + u_grad_y**2)
    v_mag = np.sqrt(v_grad_x**2 + v_grad_y**2)
    
    # Combined magnitude (Euclidean norm across channels)
    edge_magnitude = np.sqrt(L_mag**2 + u_mag**2 + v_mag**2)
    
    # Normalize edge magnitude to 0-255 range for visualization
    edge_magnitude_norm = cv2.normalize(edge_magnitude, None, 0, 255, 
                                       cv2.NORM_MINMAX).astype(np.uint8)
    
    # Step 3: Apply hysteresis thresholding
    Ec = (edge_magnitude >= high_thresh).astype(np.uint8) * 255
    Ef_temp = (edge_magnitude >= low_thresh).astype(np.uint8)
    Ef = np.zeros_like(Ef_temp)
    kernel = np.ones((3, 3), np.uint8)
    strong_dilated = cv2.dilate(Ec, kernel, iterations=1)
    Ef = cv2.bitwise_and(Ef_temp * 255, strong_dilated)
    Ef = cv2.bitwise_or(Ef, Ec)

    return Ec, Ef, edge_magnitude_norm